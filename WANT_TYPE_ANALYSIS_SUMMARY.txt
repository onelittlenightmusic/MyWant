================================================================================
MYWANT WANT TYPE DEFINITION SYSTEM - ANALYSIS SUMMARY
================================================================================

ANALYSIS COMPLETED: November 12, 2025

================================================================================
1. DOCUMENTS CREATED
================================================================================

1. WANT_TYPE_SYSTEM_ANALYSIS.md (15+ pages)
   - Comprehensive deep-dive into want type architecture
   - All core type definitions with code examples
   - Factory pattern implementation details
   - Parameter extraction patterns and techniques
   - Execution interfaces and implementation patterns
   - Connectivity metadata system
   - State management approach
   - YAML configuration structure
   - Design principles and critical patterns
   - Step-by-step guide for adding new want types
   - All want type files in codebase

2. WANT_TYPE_QUICK_REFERENCE.md (5+ pages)
   - Quick lookup reference for developers
   - Template code for new want types
   - Parameter extraction code snippets
   - Connectivity pattern examples
   - Common issues and solutions
   - Testing checklist
   - Field naming conventions
   - Key methods summary

================================================================================
2. CORE FINDINGS
================================================================================

2.1 TYPE HIERARCHY
   - Metadata: Identification and classification (name, type, labels, owner refs)
   - WantSpec: Configuration (params, using, requires, subscriptions)
   - Want: Base type with state management, history, and agent support

2.2 FACTORY PATTERN
   - Type: WantFactory = func(Metadata, WantSpec) interface{}
   - All constructors return interface{} (requires type assertion)
   - Signature: (Metadata, WantSpec) -> interface{}

2.3 CONSTRUCTOR STANDARDIZATION (Recent)
   - All want types follow consistent pattern
   - Create instance with embedded Want
   - Call Init(metadata, spec) for base initialization
   - Extract parameters from spec.Params
   - Set WantType and ConnectivityMetadata
   - Return interface{}

2.4 PARAMETER HANDLING
   - Two-phase approach:
     Phase 1: Extract in constructor for defaults
     Phase 2: Re-read in Exec() for dynamic updates
   - Type assertions required (YAML defaults to float64)
   - Must handle multiple type possibilities (int, float64, string, bool)

2.5 STATE MANAGEMENT
   - Thread-safe StoreState/GetState methods
   - Private state field with mutex protection
   - Batching mechanism via BeginExecCycle/EndExecCycle
   - Differential tracking to prevent duplicate history
   - Persistent across execution cycles

2.6 CONNECTIVITY SYSTEM
   - ConnectivityMetadata specifies input/output requirements
   - Label-based want-to-want connections via "using" selectors
   - Five architectural patterns:
     1. Generator (source, no input)
     2. Processor (input + output)
     3. Sink (input, no output)
     4. Coordinator (multiple inputs, no output)
     5. Independent (parallel execution)

2.7 REGISTRATION
   - Types registered with ChainBuilder.RegisterWantType()
   - String type name maps to factory function
   - Can wrap factories to add agent support
   - Multiple registration functions: RegisterTravelWantTypes, RegisterQNetWantTypes, etc.

================================================================================
3. WANT TYPE FILES IN CODEBASE
================================================================================

Travel Domain:
  /Users/hiroyukiosaki/work/golang/MyWant/engine/cmd/types/travel_types.go
  - RestaurantWant, HotelWant, BuffetWant, FlightWant, TravelCoordinatorWant

Queue/Network Domain:
  /Users/hiroyukiosaki/work/golang/MyWant/engine/cmd/types/qnet_types.go
  - Numbers (generator), Queue (processor), Combiner, Sink

Mathematical Domain:
  /Users/hiroyukiosaki/work/golang/MyWant/engine/cmd/types/fibonacci_types.go
  - FibonacciNumbers, FibonacciSequence
  /Users/hiroyukiosaki/work/golang/MyWant/engine/cmd/types/prime_types.go
  - PrimeNumbers, PrimeSequence, PrimeSink

System Domain:
  /Users/hiroyukiosaki/work/golang/MyWant/engine/src/owner_types.go
  - OwnerWant (dynamic want creation from recipes)
  /Users/hiroyukiosaki/work/golang/MyWant/engine/src/custom_target_types.go
  - CustomTargetWant (dynamic recipe-based types)

================================================================================
4. KEY PATTERNS IDENTIFIED
================================================================================

Pattern 1: Embedding
  All want types embed Want base type for inheritance

Pattern 2: Factory Signature
  (Metadata, WantSpec) -> interface{}

Pattern 3: Initialization Order
  1. Create with embedded Want{}
  2. Call Init(metadata, spec)
  3. Extract parameters
  4. Set WantType and ConnectivityMetadata
  5. Return interface{}

Pattern 4: Parameter Types
  - String: Direct type assertion to string
  - Numeric: Must handle both int and float64 (YAML parser default)
  - Boolean: Check both bool and string types
  - Float: Type assert to float64

Pattern 5: State Access
  - StoreState() for writing (thread-safe)
  - GetState() for reading (thread-safe)
  - Never access State field directly

Pattern 6: Connectivity
  - Generator: RequiredInputs=0, RequiredOutputs=1
  - Processor: RequiredInputs=1, RequiredOutputs=1
  - Sink: RequiredInputs=1, RequiredOutputs=0
  - Coordinator: RequiredInputs=3+, RequiredOutputs=0

Pattern 7: Dynamic Parameters
  - Constructor: Extract for defaults
  - Exec(): Re-read fresh each cycle for dynamic changes

================================================================================
5. CRITICAL DESIGN PRINCIPLES
================================================================================

1. Embedding Pattern: All types embed Want base type
2. Initialization Sequence: Create -> Init -> Extract -> Configure -> Return
3. Parameter Reading Flexibility: Extract twice (init + exec)
4. Type Safety: Factory returns interface{}, caller type-asserts
5. Connectivity Validation: ConnectivityMetadata describes interface
6. State Isolation: Private state with mutex protection
7. Thread Safety: All state access through methods, never direct access
8. Persistence: State survives across execution cycles
9. History Tracking: Automatic differential tracking of changes
10. Separation of Concerns: Domain logic separate from base infrastructure

================================================================================
6. YAML CONFIGURATION
================================================================================

Config File Format:
  wants:
    - metadata:
        name: instance_name
        type: registered_type_name     # Must match RegisterWantType call
        labels:
          key: value
      spec:
        params:
          param_name: value
        using:
          - label: value               # Input connections

Recipe File Format:
  recipe:
    parameters:
      param_name: default_value
    wants:
      - metadata:
          type: registered_type_name
        spec:
          params:
            param_name: param_name     # Reference to recipe parameter
          using:
            - role: source             # Label selector

================================================================================
7. EXTENDING THE SYSTEM
================================================================================

To add a new want type:

Step 1: Define Type
  type MyWant struct {
      Want
      CustomField string
      paths       Paths
  }

Step 2: Create Constructor
  func NewMyWant(metadata Metadata, spec WantSpec) interface{}
  - Create instance with Want{}
  - Call Init(metadata, spec)
  - Extract parameters
  - Set WantType and ConnectivityMetadata
  - Return interface{}

Step 3: Implement Exec
  func (w *MyWant) Exec(using []Chan, outputs []Chan) bool
  - Read parameters fresh
  - Check state
  - Store results
  - Send output

Step 4: Implement GetWant
  func (w *MyWant) GetWant() *Want { return &w.Want }

Step 5: Register Type
  builder.RegisterWantType("my_type_name", NewMyWant)

Step 6: Use in YAML
  type: my_type_name

================================================================================
8. RECENT CHANGES
================================================================================

Commit 97a0952: Add Init() method and refactor constructors
  - All constructors now call Init() for base initialization
  - Reduces boilerplate code in want types

Commit 540356f: Change constructors to return interface{}
  - Factory pattern for type-agnostic creation
  - Requires type assertion at call site

Commit 5df1758: Standardize want constructor signatures
  - All use (Metadata, WantSpec) pattern
  - Unified approach across codebase

Commit 6210e24: Type assertion for constructor returns
  - Explicit casting after factory calls
  - Example: want.(*RestaurantWant)

Commit ec9a9d0: Refactor to standardize want constructor signatures
  - Complete standardization of all 19 want constructors

================================================================================
9. DOCUMENT FILES
================================================================================

Created in /Users/hiroyukiosaki/work/golang/MyWant/:

1. WANT_TYPE_SYSTEM_ANALYSIS.md
   - 15+ pages of comprehensive analysis
   - All core types with examples
   - Factory pattern details
   - Parameter patterns
   - Execution interfaces
   - Connectivity system
   - State management
   - YAML configuration
   - Design principles
   - Extension guide
   - Complete file listing

2. WANT_TYPE_QUICK_REFERENCE.md
   - 5+ pages of quick reference
   - File locations
   - Type checklist
   - Constructor template
   - Registration template
   - Exec implementation template
   - Parameter type patterns
   - Connectivity patterns
   - State management patterns
   - YAML examples
   - Common issues and solutions
   - Testing checklist
   - Naming conventions
   - Methods summary

================================================================================
10. SUMMARY
================================================================================

The MyWant want type definition system is a well-designed, flexible
architecture built on:

1. Core Types: Metadata, WantSpec, Want
2. Factory Pattern: String -> Factory -> interface{}
3. Constructor Convention: (Metadata, WantSpec) -> interface{}
4. Embedding: All types inherit from Want base
5. Registration: ChainBuilder.RegisterWantType()
6. Configuration: YAML-based declarative syntax
7. Connectivity: Label-based want-to-want connections
8. State: Thread-safe persistent storage with history
9. Execution: Exec() method with channel I/O
10. Parameters: Two-phase reading for flexibility

This design enables:
- Easy extension with new want types
- Type-safe execution without losing flexibility
- Runtime parameter changes
- Complex multi-want architectures
- Declarative YAML-based configuration
- Concurrent safe execution
- Complete state history tracking

The system has been refined through recent commits to standardize
constructor signatures and improve consistency across all want types.

================================================================================
