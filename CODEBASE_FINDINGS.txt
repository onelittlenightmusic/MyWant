==============================================================================
MYWANT CODEBASE ANALYSIS - RECIPE LOADING AND WANT TYPE SYSTEM
==============================================================================

EXECUTIVE SUMMARY
-----------------

The MyWant codebase implements a sophisticated two-tier configuration system:
1. Want Types (Go): Static constructor functions for low-level units
2. Recipes (YAML): Reusable templates that compose want types
3. Configs (YAML): User-facing interface that reference recipes

The server loads everything at startup through distinct phases.


1. RECIPE LOADER SYSTEM - HOW IT WORKS
========================================

Main File: recipe_loader_generic.go (706 lines)
Key Class: GenericRecipeLoader

Workflow:
---------
Config File (YAML)
    ↓
LoadRecipeWithConfig()
    ↓
GenericRecipeLoader.LoadRecipe()
    ├─ Read recipe YAML file
    ├─ Validate against OpenAPI spec
    ├─ Merge parameters (recipe defaults + overrides)
    ├─ Substitute parameter references (simple string matching)
    ├─ Generate want names (prefix-type-index)
    ├─ Namespace labels and using selectors
    └─ Return GenericRecipeConfig with Want objects
    ↓
ChainBuilder.Execute()
    ↓
Want.Exec() for each want


Data Flow Example:
------------------

Input - Config File:
  recipe:
    path: recipes/travel-itinerary.yaml
    parameters:
      prefix: "travel"
      restaurant_type: "fine dining"

Input - Recipe File (recipes/travel-itinerary.yaml):
  recipe:
    metadata:
      name: "Travel Itinerary"
    parameters:
      prefix: "travel"
      restaurant_type: "casual"
    wants:
      - type: restaurant
        params:
          restaurant_type: restaurant_type  # parameter reference!

Process:
  1. Merge params: {prefix: "travel", restaurant_type: "fine dining"}
  2. Substitute: restaurant_type: "fine dining" (from params)
  3. Generate name: "travel-restaurant-1"
  4. Create Want object with substituted params

Output - Config object ready for execution


Key Methods in GenericRecipeLoader:
------------------------------------
LoadRecipe(path, params)
  - Main entry point
  - Returns GenericRecipeConfig with processed wants
  
ValidateRecipe(path)
  - Checks YAML structure and OpenAPI compliance
  
ListRecipes()
  - Enumerate all recipe files in directory
  
GetRecipeMetadata(path)
  - Extract name, description, type, custom_type
  
GetRecipeParameters(path)
  - Extract parameter definitions from recipe
  
ScanAndRegisterCustomTypes(dir, registry)
  - Register recipes with custom_type metadata as deployable types


2. ALL WANT TYPE IMPLEMENTATIONS
==================================

Location: engine/cmd/types/ and engine/src/

DOMAIN-SPECIFIC TYPES (engine/cmd/types/):
-------------------------------------------

travel_types.go (2 constructors + helpers):
  - NewFlightWant() → "flight"
  - NewRestaurantWant() → "restaurant"
  - NewHotelWant() → "hotel"
  - NewBuffetWant() → "buffet"
  - NewTravelCoordinatorWant() → "travel_coordinator"
  Registration: RegisterTravelWantTypes(builder) [5 types]

qnet_types.go (4 constructors):
  - PacketNumbers() → "qnet numbers"
  - NewQueue() → "qnet queue"
  - NewCombiner() → "qnet combiner"
  - Goal() → "qnet sink" / "qnet collector"
  Registration: RegisterQNetWantTypes(builder) [5 types]

fibonacci_types.go (3 constructors):
  - NewFibonacciWant() → "fibonacci"
  - NewFibonacciSourceWant() → "fibonacci_source"
  - NewFibonacciAdderWant() → "fibonacci_adder"
  Registration: RegisterFibonacciWantTypes(builder) [3 types]

fibonacci_loop_types.go (3 constructors):
  - NewFibonacciLoopWant() → "fibonacci_loop"
  - NewFibonacciSourceLoopWant() → "fibonacci_source_loop"
  - NewFibonacciAdderLoopWant() → "fibonacci_adder_loop"
  Registration: RegisterFibonacciLoopWantTypes(builder) [3 types]

prime_types.go (3 constructors):
  - NewPrimeWant() → "prime"
  - NewSieveWant() → "sieve"
  - NewPrimeSourceWant() → "prime_source"
  Registration: RegisterPrimeWantTypes(builder) [3 types]

approval_types.go (3 constructors):
  - NewApprovalWant() → "approval"
  - NewApprovalDecisionWant() → "approval_decision"
  - NewApprovalEscalationWant() → "approval_escalation"
  Registration: RegisterApprovalWantTypes(builder) [3 types]

SYSTEM-LEVEL TYPES (engine/src/):
----------------------------------

owner_types.go (1 constructor):
  - NewOwnerWant() → "owner"
  - Enables parent-child want relationships
  Registration: RegisterOwnerWantTypes(builder) [1 type]

monitor_types.go (1 constructor):
  - NewMonitorWant() → "monitor"
  - Polling/monitoring want type
  Registration: RegisterMonitorWantTypes(builder) [1 type]

TOTAL WANT TYPES: 23 different types across 8 files

Constructor Signature (All):
  func New*Want(metadata Metadata, spec WantSpec) interface{}


3. HOW RECIPES ARE LOADED AT STARTUP
=====================================

Server Initialization: engine/cmd/server/main.go

Phase 1 - NewServer() (lines 134-182):
  ├─ Create AgentRegistry
  ├─ Create CustomTargetTypeRegistry
  ├─ Load agents/capabilities from directories
  ├─ ScanAndRegisterCustomTypes("recipes")
  │   └─ Reads all recipes, extracts custom_type metadata
  ├─ loadRecipeFilesIntoRegistry("recipes")
  │   ├─ List all YAML files in recipes/
  │   ├─ Parse each into GenericRecipe
  │   ├─ Create in registry by name
  │   └─ Log loaded recipes
  ├─ Create global ChainBuilder
  └─ Set AgentRegistry on builder

Phase 2 - Server.Start() (lines 1530-1546):
  ├─ Call setupRoutes()
  ├─ Register want types:
  │   ├─ types.RegisterQNetWantTypes(globalBuilder)
  │   ├─ types.RegisterFibonacciWantTypes(globalBuilder)
  │   ├─ types.RegisterPrimeWantTypes(globalBuilder)
  │   ├─ types.RegisterTravelWantTypes(globalBuilder)
  │   ├─ types.RegisterApprovalWantTypes(globalBuilder)
  │   ├─ mywant.RegisterMonitorWantTypes(globalBuilder)
  │   └─ mywant.RegisterOwnerWantTypes(globalBuilder)
  ├─ Start global reconcile loop: ExecuteWithMode(true)
  └─ Start HTTP server

Recipe Loading Functions (main.go):
  
  ScanAndRegisterCustomTypes(recipeDir, registry) [recipe_loader_generic.go:656]
    - Scans recipes directory
    - For each recipe with metadata.custom_type:
      ├─ Extract metadata
      ├─ Get default parameters
      └─ RegisterCustomTargetType(registry, typename, description, path, params)
    - Logs registered custom types
  
  loadRecipeFilesIntoRegistry(recipeDir, registry) [main.go:1864]
    - Iterates all YAML files in recipes/
    - For each file:
      ├─ Read file
      ├─ Unmarshal to GenericRecipe
      ├─ Extract recipe name from metadata or filename
      ├─ Create recipe in registry
      └─ Log result


4. DIRECTORY STRUCTURE ANALYSIS
================================

Current Structure:
  MyWant/
  ├── recipes/                  (12 recipe files)
  │   ├── travel-itinerary.yaml
  │   ├── queue-system.yaml
  │   ├── qnet-pipeline.yaml
  │   ├── fibonacci-sequence.yaml
  │   ├── fibonacci-pipeline.yaml
  │   ├── prime-sieve.yaml
  │   ├── approval-level-1.yaml
  │   ├── approval-level-2.yaml
  │   ├── dynamic-travel-change.yaml
  │   ├── travel-agent.yaml
  │   ├── travel-itinerary-agent.yaml
  │   └── README.md
  │
  ├── config/                   (13 config files)
  │   ├── config-travel-recipe.yaml
  │   ├── config-qnet-recipe.yaml
  │   ├── config-fibonacci-recipe.yaml
  │   ├── config-prime-recipe.yaml
  │   ├── ... (9 more configs)
  │
  ├── engine/
  │   ├── src/
  │   │   ├── declarative.go (main Config/Want/Recipe types)
  │   │   ├── recipe_loader_generic.go (GenericRecipeLoader - 706 lines)
  │   │   ├── recipe_loader.go (RecipeLoader legacy - 490 lines)
  │   │   ├── owner_types.go (Owner want type)
  │   │   ├── monitor_types.go (Monitor want type)
  │   │   └── [other core files]
  │   │
  │   └── cmd/
  │       ├── types/
  │       │   ├── travel_types.go (5 travel want types)
  │       │   ├── qnet_types.go (5 qnet want types)
  │       │   ├── fibonacci_types.go (3 fibonacci types)
  │       │   ├── fibonacci_loop_types.go (3 fibonacci_loop types)
  │       │   ├── prime_types.go (3 prime types)
  │       │   ├── approval_types.go (3 approval types)
  │       │   └── flight_types.go (flight API agents)
  │       │
  │       ├── server/
  │       │   └── main.go (Server with startup logic)
  │       │
  │       └── demos/ (18+ demo programs)


5. PATTERN FOR LOADING WANT TYPE YAMLs
========================================

The question: Can we load want type definitions from YAML?

Current System:
  - Want types are defined as Go constructor functions
  - Registered via Register*WantTypes() functions
  - All registration happens in main.go before execution

Why Not Load Want Type YAML:

1. Constructors are Go functions
   - Need to call NewRestaurantWant(metadata, spec)
   - YAML can't execute Go code
   - Would need reflection + dynamic function lookup
   - Adds complexity vs. current approach

2. Type safety lost
   - Go compiler checks constructor signatures
   - Parameter extraction code type-safe
   - YAML would require runtime validation

3. Current pattern already works well
   - All types registered in server startup
   - Scalable to any number of types
   - Demo programs use same registration

Alternative: Load Recipe YAML (Already Implemented)

The system DOES load YAML at startup:
  - Recipes: 12 YAML files loaded into memory
  - Each recipe can define custom_type
  - Custom types registered as deployable units
  - Parameters parameterized for flexibility

This is the RIGHT approach because:
  - Recipes compose want types
  - Recipes are user-facing configs
  - Can be deployed multiple times with different params
  - Pure YAML, no need for Go execution


6. RECOMMENDATIONS FOR UNDERSTANDING THE PATTERN
==================================================

To follow the architecture pattern:

1. Want Types (Keep as Go):
   - Define constructors in *_types.go files
   - Register in Register*WantTypes() functions
   - Call from server startup

2. Recipes (Load from YAML):
   - Define reusable compositions of wants
   - Include parameters for customization
   - Include metadata for discovery
   - Already supported: custom_type for categorization

3. Configs (Load from YAML):
   - User-facing interface
   - Reference recipes by path
   - Override recipe parameters
   - One-time deployments

Pattern Summary:
  Go Code      → Want Types    → Register*WantTypes()
  YAML Recipes → Compose Wants → ScanAndRegisterCustomTypes()
  YAML Configs → Deploy Recipes → CreateWant() API


7. KEY FILES FOR REFERENCE
===========================

To understand the architecture:

recipe_loader_generic.go (706 lines)
  - GenericRecipeLoader class
  - LoadRecipe() main algorithm
  - Parameter substitution logic
  - Custom type registration

main.go (1989 lines)
  - Server startup sequence
  - NewServer() → creates registries, loads recipes
  - Start() → registers want types, starts execution
  - loadRecipeFilesIntoRegistry() → loads YAML recipes

declarative.go (core definitions)
  - Config struct
  - Want struct
  - WantSpec struct
  - Metadata struct
  - GenericRecipe / RecipeWant structs

travel_types.go (example implementation)
  - RegisterTravelWantTypes() pattern
  - NewRestaurantWant() constructor pattern
  - Parameter extraction from spec.Params


8. COMPLETE WANT TYPE INVENTORY
================================

Travel Domain (5):
  1. flight - Book flights
  2. restaurant - Reserve dining
  3. hotel - Book accommodation
  4. buffet - Reserve buffet dining
  5. travel_coordinator - Orchestrate travel plans

Queue Network Domain (5):
  1. qnet numbers - Packet generator
  2. qnet queue - Queue processor
  3. qnet combiner - Combine multiple streams
  4. qnet sink - Absorb/collect packets (also: qnet collector)

Fibonacci Domain (6):
  1. fibonacci - Basic fibonacci computation
  2. fibonacci_source - Fibonacci sequence source
  3. fibonacci_adder - Fibonacci computation
  4. fibonacci_loop - Loop-based fibonacci
  5. fibonacci_source_loop - Loop-based source
  6. fibonacci_adder_loop - Loop-based adder

Prime Domain (3):
  1. prime - Prime computation
  2. sieve - Sieve algorithm
  3. prime_source - Prime sequence source

Approval Domain (3):
  1. approval - Approval want
  2. approval_decision - Decision point
  3. approval_escalation - Escalation handling

System Domain (2):
  1. owner - Parent-child relationships, dynamic creation
  2. monitor - Polling/monitoring capabilities


TOTAL: 24 want types across 8 implementation files


CONCLUSION
==========

MyWant implements a well-structured pattern:

1. Static Want Type Registration (Go):
   - Happens once at server startup
   - Provides type definitions
   - All 23+ types registered

2. Dynamic Recipe Loading (YAML):
   - Happens at startup from recipes/ directory
   - Provides reusable templates
   - Each recipe can be deployed multiple times

3. User-Facing Configs (YAML):
   - Reference recipes
   - Override parameters
   - Deploy complete workflows

The pattern is clean, maintainable, and extensible.
To load want type definitions from YAML would be:
  - Unnecessary complexity
  - Loss of type safety
  - Duplication with recipe system

Current approach is optimal for the use case.
