================================================================================
TARGET WANT EXECUTION AND OWNERREFERENCES SETUP - FINDINGS SUMMARY
================================================================================

QUESTION 1: Where Target type wants are executed (Exec() method)
================================================================================
LOCATION: /Users/hiroyukiosaki/work/golang/MyWant/engine/src/owner_types.go
METHOD: func (t *Target) Exec(inputs []chain.Chan, outputs []chain.Chan) bool
LINES: 268-342

Key logic:
- Line 272: Checks if builder is available
- Line 274: Calls CreateChildWants() to dynamically create child wants
- Line 284: Calls builder.AddWantsAsync(childWants) to add them asynchronously
- Line 307: Blocks on <-t.childrenDone waiting for all children to complete
- Line 311: Calls computeTemplateResult() to aggregate child results
- Line 314: Marks target as completed

QUESTION 2: Where child wants from recipes are created and added
================================================================================
LOCATION: /Users/hiroyukiosaki/work/golang/MyWant/engine/src/owner_types.go
METHOD: func (t *Target) CreateChildWants() []*Want
LINES: 227-265

Key flow:
1. Line 235: Calls t.recipeLoader.LoadConfigFromRecipe(t.RecipePath, t.RecipeParams)
2. Returns Config with Want array (no OwnerReferences yet)
3. Lines 244-261: CRITICAL SECTION - Sets OwnerReferences on all child wants
4. Line 264: Caches child wants in t.childWants
5. Line 265: Returns the child wants array

QUESTION 3: Where are child Target wants' Metadata.OwnerReferences set?
================================================================================
LOCATION: /Users/hiroyukiosaki/work/golang/MyWant/engine/src/owner_types.go
METHOD: func (t *Target) CreateChildWants()
LINES: 244-261 (EXACT CODE):

    for i := range config.Wants {
        config.Wants[i].Metadata.OwnerReferences = []OwnerReference{
            {
                APIVersion:         "MyWant/v1",
                Kind:               "Want",
                Name:               t.Metadata.Name,        // Parent Target name
                ID:                 t.Metadata.ID,          // Parent Target ID
                Controller:         true,
                BlockOwnerDeletion: true,
            },
        }
        // Add owner label for easier identification
        if config.Wants[i].Metadata.Labels == nil {
            config.Wants[i].Metadata.Labels = make(map[string]string)
        }
        config.Wants[i].Metadata.Labels["owner"] = "child"
    }

ANSWER: YES, OwnerReferences ARE properly set for all child Target wants!
- Each child want gets exactly one OwnerReference
- The OwnerReference includes parent Target's Name and ID
- Controller is set to true (marks controlling ownership)
- BlockOwnerDeletion is true (enables cascade deletion)
- An "owner: child" label is added for identification

QUESTION 4: Code that creates Target instances with OwnerReferences
================================================================================
LOCATION 1: /Users/hiroyukiosaki/work/golang/MyWant/engine/src/chain_builder.go
METHOD: func (cb *ChainBuilder) createWantFunction(want *Want) (interface{}, error)
LINES: 266-270

When child wants are created by the reconcile loop:
    if len(want.Metadata.OwnerReferences) > 0 {
        wantInstance = NewOwnerAwareWant(wantInstance, want.Metadata)
    }

This automatically wraps any want (including child Targets) with OwnerAwareWant
if it has OwnerReferences, enabling parent notification.

LOCATION 2: /Users/hiroyukiosaki/work/golang/MyWant/engine/src/chain_builder.go
METHOD: func (cb *ChainBuilder) createCustomTargetWant(want *Want) (interface{}, error)
LINES: 302-307

For custom target types:
    var wantInstance interface{} = target
    if len(want.Metadata.OwnerReferences) > 0 {
        wantInstance = NewOwnerAwareWant(wantInstance, want.Metadata)
    }

This also wraps custom targets (which may be nested under other targets) with
OwnerAwareWant if they have OwnerReferences.

================================================================================
COMPLETE EXECUTION PATH - VISUALIZED
================================================================================

1. Target.Exec() starts (line 268)
   |
   +-- Check builder available (line 272)
   |
   +-- CreateChildWants() called (line 274)
       |
       +-- LoadConfigFromRecipe() (line 235)
       |   Returns Config WITHOUT OwnerReferences
       |
       +-- FOR EACH child want (line 245)
       |   |
       |   +-- SET OwnerReferences (lines 246-254)
       |   |   Name: parent Target name
       |   |   ID: parent Target ID
       |   |   Controller: true
       |   |
       |   +-- Add "owner: child" label (line 260)
       |
       +-- Return childWants array (line 265)
   |
   +-- AddWantsAsync() to reconcile loop (line 284)
       |
       +-- Reconcile loop receives (chain_builder.go:422)
       |   |
       |   +-- FOR EACH want: addWant(want) (line 429)
       |       |
       |       +-- createWantFunction(want) (line 1212)
       |           |
       |           +-- Check OwnerReferences (chain_builder.go:268)
       |           |
       |           +-- IF OwnerReferences exist:
       |           |   |
       |           |   +-- Wrap with OwnerAwareWant (chain_builder.go:269)
       |           |
       |           +-- Return wrapped/unwrapped instance
       |
       +-- Trigger reconciliation (line 435)
   |
   +-- Block waiting for children (line 307)
       <-t.childrenDone
       |
       +-- TargetCompletionSubscription.OnEvent() receives completion events
       |   (owner_types.go:106)
       |   |
       |   +-- Track child completion (line 122)
       |   |
       |   +-- Check if all done (line 125)
       |   |
       |   +-- Signal channel if all done (line 132)
       |
       +-- Target wakes up (line 307)
   |
   +-- Compute result (line 311)
   |
   +-- Mark completed (line 314)
   |
   +-- Return true (line 341)

================================================================================
KEY FINDINGS SUMMARY
================================================================================

1. OwnerReferences ARE PROPERLY SET
   - Location: owner_types.go lines 244-261
   - ALL child wants get OwnerReferences pointing to parent Target
   - Includes parent Name, ID, and metadata
   
2. OwnerReferences Enable Parent-Child Coordination
   - Child wants are wrapped with OwnerAwareWant (chain_builder.go:269)
   - OwnerAwareWant emits OwnerCompletionEvent on completion
   - Parent Target's TargetCompletionSubscription receives events
   
3. Async Addition via Reconcile Loop
   - Target calls AddWantsAsync() (owner_types.go:284)
   - Reconcile loop handles addition (chain_builder.go:422-435)
   - Automatic wrapping happens during want creation
   
4. Parent-Child Synchronization
   - Parent blocks on childrenDone channel (owner_types.go:307)
   - Children notify via OwnerCompletionEvent (owner_types.go:611)
   - Parent tracks completion via TargetCompletionSubscription (owner_types.go:106-145)

5. No Missing OwnerReferences Setup
   - OwnerReferences are set BEFORE adding wants to builder
   - Wrapping happens DURING want creation in reconcile loop
   - Everything is properly connected and working

================================================================================
FILE LOCATIONS
================================================================================

Main files involved:
- /Users/hiroyukiosaki/work/golang/MyWant/engine/src/owner_types.go
  * Target struct and Exec() method
  * CreateChildWants() method where OwnerReferences are set
  * OwnerAwareWant wrapper
  * TargetCompletionSubscription event handler

- /Users/hiroyukiosaki/work/golang/MyWant/engine/src/chain_builder.go
  * createWantFunction() where wrapping happens
  * createCustomTargetWant() for custom Target types
  * reconcileLoop() async want addition handler
  * addWant() called from reconcile loop

- /Users/hiroyukiosaki/work/golang/MyWant/engine/src/recipe_loader_generic.go
  * LoadConfigFromRecipe() loads wants (without OwnerReferences)
  * GenericRecipeLoader handles recipe processing

================================================================================
